package info.qbnet.jtvision.views;

import info.qbnet.jtvision.util.Command;
import info.qbnet.jtvision.event.TEvent;
import info.qbnet.jtvision.util.TPoint;
import info.qbnet.jtvision.util.TRect;
import info.qbnet.jtvision.util.TStream;
import info.qbnet.jtvision.util.Buffer;
import info.qbnet.jtvision.util.IBuffer;

import java.nio.ByteBuffer;
import java.util.Set;
import java.util.List;
import java.util.ArrayList;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.io.IOException;

/**
 * TGroup objects and their derivatives (which we call groups for short)
 * provide the central driving power to Turbo Vision. A group is a special
 * breed of view. In addition to all the fields and methods derived from
 * TView, a group has additional fields and methods (including many
 * overrides) allowing it to control a dynamically linked list of views
 * (including other groups) as though they were a single object. We often talk
 * about the subviews of a group even when these subviews are often
 * groups in their own right.
 *
 * Although a group has a rectangular boundary from its TView ancestry, a
 * group is only visible through the displays of its subviews. A group
 * conceptually draws itself via the draw methods of its subviews. A group
 * owns its subviews, and together they must be capable of drawing (filling)
 * the group's entire rectangular bounds. During the life of an application,
 * subviews and subgroups are created, inserted into groups, and displayed
 * as a result of user activity and events generated by the application itself.
 * The subviews can just as easily be hidden, deleted from the group, or
 * disposed of by user actions (such as closing a window or quitting a dialog box).
 *
 * The three derived object types of TGroup, namely TWindow, TDeskTop, and
 * TApplication (via TProgram) illustrate the group and subgroup concept.
 * TApplication will typically own a TDeskTop object, a TStatusLine object, and
 * a TMenuView object. TDeskTop is a TGroup derivative, so it, in turn, can
 * own TWindow objects, which in turn own TFrame objects, TScrollBar
 * objects, and so on.
 *
 * TGroup objects delegate both drawing and event handling to their
 * subviews. Many of the basic TView methods are overridden in TGroup
 * in a natural way. For example, storing and loading groups on streams
 * can be achieved with single calls to TGroup.store and TGroup.load.
 *
 * TGroup objects are not usually instantiated directly; rather you would
 * instantiate one or more of TGroup's derived object types: TApplication,
 * TDeskTop, and TWindow.
 */
public class TGroup extends TView {

    public static final int CLASS_ID = 6;

    public static void registerType() {
        TStream.registerType(CLASS_ID, TGroup::new);
    }

    /**
     * Tracks the group currently being loaded from a {@link TStream} to ensure
     * the {@link #awaken()} hook is invoked only once after the entire view
     * hierarchy has been constructed.
     */
    private static TGroup loadingGroup = null;

    static TGroup getLoadingGroup() {
        return loadingGroup;
    }

    private static class PeerFixup {
        final int index;
        final Consumer<TView> setter;

        PeerFixup(int index, Consumer<TView> setter) {
            this.index = index;
            this.setter = setter;
        }
    }

    private final List<PeerFixup> peerFixups = new ArrayList<>();

    void addPeerFixup(int index, Consumer<TView> setter) {
        peerFixups.add(new PeerFixup(index, setter));
    }

    private void resolvePeerFixups() {
        if (!peerFixups.isEmpty()) {
            for (PeerFixup fx : peerFixups) {
                TView v = at(fx.index);
                if (v != null) {
                    fx.setter.accept(v);
                }
            }
            peerFixups.clear();
        }
    }

    @Override
    public int getClassId() {
        return CLASS_ID;
    }

    /**
     * Points to the last subview in the group (the one furthest from the top in
     * Z-order). The next field of the last subview points to the first subview,
     * whose next field points to the next subview, and so on, forming a circular list.
     */
    protected TView last = null;

    /**
     * Points to the subview that is currently selected, or is null if no subview is
     * selected.
     */
    protected TView current = null;

    public enum Phase { FOCUSED, PRE_PROCESS, POST_PROCESS }

    public Phase phase = Phase.FOCUSED;

    /**
     * Points to a buffer used to cache redraw operations, or is null if the group
     * has no cache buffer. Cache buffers are created and destroyed
     * automatically, unless the OF_BUFFERED flag is cleared in the group's Options
     * field.
     */
    protected IBuffer buffer = null;

    protected int endState = 0;

    /**
     * Stores the clipping rectangle for the group.
     */
    protected TRect clip = new TRect(0, 0, 0, 0);

    /**
     * Used to lock view updates during complex operations.
     */
    protected int lockFlag = 0;

    /**
     * Enumerates selection modes when changing the current view.
     */
    enum SelectMode {
        NORMAL_SELECT,
        ENTER_SELECT,
        LEAVE_SELECT,
    }

    /**
     * Constructs a new TGroup within the given bounds.
     * Calls TView constructor, sets OF_SELECTABLE and OF_BUFFERED in Options,
     * and sets EventMask to 0xFFFF.
     */
    public TGroup(TRect bounds) {
        super(bounds);
        options |= Options.OF_SELECTABLE | Options.OF_BUFFERED;
        getExtent(clip);
        eventMask = 0xFFFF;

        logger.debug("{} TGroup@TGroup(bounds={})", getLogName(), bounds);
    }

    public TGroup(TStream stream) {
        super(stream);
        getExtent(clip);

        TGroup previous = loadingGroup;
        loadingGroup = this;
        try {
            int count = stream.readInt();
            for (int i = 0; i < count; i++) {
                TView child = stream.loadView();
                // Insert subviews in the same order as they were stored to
                // ensure indices used by getSubViewPtr remain valid.
                insertBefore(child, null);
            }
            TView sel = getSubViewPtr(stream);
            setCurrent(sel, SelectMode.NORMAL_SELECT);
            resolvePeerFixups();
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            loadingGroup = previous;
        }

        if (previous == null) {
            awaken();
        }
    }

    @Override
    public void awaken() {
        logger.trace("{} TGroup@awaken()", getLogName());
        forEach(TView::awaken);
    }

    @Override
    public void changeBounds(TRect bounds) {
        TPoint d = new TPoint(bounds.b.x - bounds.a.x - size.x, bounds.b.y - bounds.a.y - size.y);
        if (d.x == 0 && d.y == 0) {
            setBounds(bounds);
            drawView();
        } else {
            freeBuffer();
            setBounds(bounds);
            getExtent(clip);
            getBuffer();
            lock();
            forEach(p -> {
                TRect r = new TRect();
                p.calcBounds(r, d);
                p.changeBounds(r);
            });
            unlock();
        }
    }

    @Override
    public int dataSize() {
        int size = super.dataSize();
        if (last != null) {
            TView first = last.getNext();
            TView p = first;
            do {
                size += p.dataSize();
                p = p.getNext();
            } while (p != first);
        }
        return size;
    }

    public void delete(TView p) {
        logger.trace("{} TGroup@delete({})", getLogName(), p.getLogName());

        int saveState = p.state;
        p.hide();
        removeView(p);
        p.owner = null;
        p.next = null;
        if ((saveState & State.SF_VISIBLE) != 0) {
            p.show();
        }
    }

    @Override
    public void store(TStream stream) {
        super.store(stream);
        try {
            stream.writeInt(indexOf(last));
            forEach(v -> {
                try {
                    stream.storeView(v);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            });
            putSubViewPtr(stream, current);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    protected void done() {
        hide();
        TView p = last;
        if (p != null) {
            do {
                p.hide();
                p = p.prev();
            } while (p != last);
            do {
                TView t = p.prev();
                p.done();
                p = t;
            } while (last != null);
        }
        freeBuffer();
        super.done();
    }

    /**
     * Overrides TView.draw. If a cache buffer exists (see TGroup.buffer field),
     * then the buffer is written to the screen using TView.writeBuf.
     * Otherwise, each subview is told to draw itself using a call to TGroup.drawSubViews.
     */
    @Override
    public void draw() {
        logger.trace("{} TGroup@draw()", getLogName());

        if (buffer == null) {
            getBuffer();
        }

        if (buffer != null) {
            lockFlag++;
            redraw();
            lockFlag--;
            writeBuf(0, 0, size.x, size.y, buffer.getData());
        } else {
            getClipRect(clip);
            redraw();
            getExtent(clip);
        }

        // CHECK: always redraw buffer (CM_PREV problem), original implementation
//        if (buffer == null) {
//            getBuffer();
//            if (buffer != null) {
//                lockFlag++;
//                redraw();
//                lockFlag--;
//            }
//        }
//
//        if (buffer != null) {
//            writeBuf(0, 0, size.x, size.y, buffer.getData());
//        } else {
//            getClipRect(clip);
//            redraw();
//            getExtent(clip);
//        }
    }

    /**
     * Draws a range of subviews starting from p up to but not including bottom.
     */
    void drawSubViews(TView p, TView bottom) {
        if (p != null) {
            while (p != bottom) {
                p.drawView();
                p = p.nextView();
            }
        }
    }

    @Override
    public void endModal(int command) {
        if ((state & State.SF_MODAL) != 0) {
            endState = command;
        } else {
            super.endModal(command);
        }
    }

    public void eventError(TEvent event) {
        if (owner != null) {
            owner.eventError(event);
        }
    }

    @Override
    public int execute() {
        TEvent e = new TEvent();
        do {
            endState = 0;
            do {
                getEvent(e);
                handleEvent(e);
                if (e.what != TEvent.EV_NOTHING) {
                    eventError(e);
                }
            } while (endState == 0);
        } while (!valid(endState));
        return endState;
    }

    public int execView(TView p) {
        int result = Command.CM_CANCEL;
        if (p != null) {
            int saveOptions = p.options;
            TGroup saveOwner = p.owner;
            TView saveTopView = theTopView;
            TView saveCurrent = current;
            Set<Integer> saveCommands = getCommands();
            theTopView = p;
            p.options = saveOptions & ~Options.OF_SELECTABLE;
            p.setState(State.SF_MODAL, true);
            setCurrent(p, SelectMode.ENTER_SELECT);
            if (saveOwner == null) {
                insert(p);
            }
            result = p.execute();
            if (saveOwner == null) {
                delete(p);
            }
            setCurrent(saveCurrent, SelectMode.LEAVE_SELECT);
            p.setState(State.SF_MODAL, false);
            p.options = saveOptions;
            theTopView = saveTopView;
            setCommands(saveCommands);
        }

        return result;
    }

    private TView findNext(boolean forwards) {
        if (current != null) {
            TView p = current;
            do {
                p = forwards ? p.next : p.prev();
            } while (((p.state & (State.SF_VISIBLE | State.SF_DISABLED)) != State.SF_VISIBLE
                    || (p.options & Options.OF_SELECTABLE) == 0) && p != current);
            if (p != current) {
                return p;
            }
        }
        return null;
    }

    /**
     * Returns a reference to the first subview (the one closest to the top in Z-order),
     * or null if the group has no subviews.
     */
    public TView first() {
        if (last == null)
            return null;
        else
            return last.getNext();
    }

    /**
     * Returns the first view that matches the given state and options flags.
     */
    private TView firstMatch(int state, int options) {
        return firstThat(v -> (v.state & state) == state && (v.getOptions() & options) == options);
    }

    /**
     * Applies a boolean predicate to each subview in Z-order until the predicate returns true.
     * The result is the subview for which the predicate returned true, or null if it returned false
     * for all subviews.
     *
     * <p>This method is typically used to implement search functions such as hit-testing.</p>
     */
    public TView firstThat(Predicate<TView> predicate) {
        if (last == null) return null;

        TView current = last.getNext();
        do {
            if (predicate.test(current)) return current;
            current = current.getNext();
        } while (current != last.getNext());

        return null;
    }

    public boolean focusNext(boolean forwards) {
        TView p = findNext(forwards);
        if (p != null) {
            return p.focus();
        }
        return true;
    }

    public void forEach(Consumer<TView> action) {
        if (last == null) return;

        TView current = last.getNext();
        TView n;
        do {
            n = current.getNext();
            action.accept(current);
            if (current == null || last == null) {
                return;
            }
            current = n;
        } while (current != last.getNext());
    }

    private void freeBuffer() {
        if ((options & Options.OF_BUFFERED) != 0 && buffer != null) {
            buffer.dispose();
            buffer = null;
        }
    }

    private void getBuffer() {
        if (buffer != null) {
            return;
        }
        if ((state & State.SF_EXPOSED) == 0) {
            return;
        }
        if ((getOptions() & Options.OF_BUFFERED) == 0) {
            return;
        }
        buffer = new Buffer(size.x, size.y);
    }

    @Override
    public void getData(ByteBuffer dst) {
        if (last == null) return;

        TView p = last.getNext();
        do {
            int sz = p.dataSize();
            ByteBuffer slice = dst.slice();
            slice.limit(sz);
            p.getData(slice);
            dst.position(dst.position() + sz);
            p = p.getNext();
        } while (p != last.getNext());
    }

    @Override
    public int getHelpCtx() {
        int h = HelpContext.HC_NO_CONTEXT;
        if (current != null) {
            h = current.getHelpCtx();
        }
        if (h == HelpContext.HC_NO_CONTEXT) {
            h = super.getHelpCtx();
        }
        return h;
    }

    /**
     * Reads a pointer to a subview previously written with
     * {@link #putSubViewPtr(TStream, TView)}. The returned view belongs to this
     * group or {@code null} if the stored index was {@code 0} or out of range.
     *
     * <p>This corresponds to Turbo Vision's {@code TGroup.GetSubViewPtr}.</p>
     */
    public TView getSubViewPtr(TStream stream) throws IOException {
        int index = stream.readInt();
        return index > 0 ? at(index) : null;
    }

    @Override
    public void handleEvent(TEvent event) {
        boolean logEvent = LOG_EVENTS && event.what != TEvent.EV_NOTHING;
        if (logEvent) {
            logger.trace("{} TGroup@handleEvent(event={})", getLogName(), event);
        }

        Consumer<TView> doHandleEvent = p -> {
            if (p == null || ((p.state & State.SF_DISABLED) != 0 && (event.what & (TEvent.POSITIONAL_EVENTS | TEvent.FOCUSED_EVENTS)) != 0)) {
                return;
            }
            switch (phase) {
                case PRE_PROCESS:
                    if ((p.options & Options.OF_PRE_PROCESS) == 0) return;
                    break;
                case POST_PROCESS:
                    if ((p.options & Options.OF_POST_PROCESS) == 0) return;
                    break;
            }
            if ((event.what & p.eventMask) != 0) {
                boolean childLog = LOG_EVENTS && event.what != TEvent.EV_NOTHING;
                if (childLog) {
                    logger.trace("{} TGroup@handleEvent -> {} event={}", getLogName(),
                            p.getLogName(), event);
                }
                int before = event.what;
                p.handleEvent(event);
                if (childLog) {
                    logger.trace("{} TGroup@handleEvent <- {} handled={} event={}", getLogName(),
                            p.getLogName(), event.what == TEvent.EV_NOTHING && before != TEvent.EV_NOTHING, event);
                }
            }
        };

        Predicate<TView> containsMouse = p ->
                ((p.state & State.SF_VISIBLE) != 0) && p.mouseInView(event.mouse.where);

        super.handleEvent(event);

        if ((event.what & TEvent.FOCUSED_EVENTS) != 0) {
            phase = Phase.PRE_PROCESS;
            forEach(doHandleEvent);
            phase = Phase.FOCUSED;
            if (current == null) {
                System.err.println("TGroup@handleEvent() current is null");
            }
            doHandleEvent.accept(current);
            phase = Phase.POST_PROCESS;
            forEach(doHandleEvent);
        } else {
            phase = Phase.FOCUSED;
            if ((event.what & TEvent.POSITIONAL_EVENTS) != 0)
                doHandleEvent.accept(firstThat(containsMouse));
            else
                forEach(doHandleEvent);
        }

        if (logEvent) {
            logger.trace("{} TGroup@handleEvent() eventAfter={} handled={}",
                    getLogName(), event, event.what == TEvent.EV_NOTHING);
        }
    }

    /**
     * Returns the 1-based index of {@code view} in this group's circular
     * subview list. The first subview (closest to the top in Z-order)
     * has index {@code 1}. If the supplied view is not a member of this
     * group or the group has no subviews, {@code 0} is returned.
     *
     * <p>This is a direct translation of the Turbo Vision {@code TGroup.IndexOf}
     * routine, which traverses the ring of subviews starting from {@code last}.</p>
     */
    public int indexOf(TView view) {
        if (last == null || view == null) {
            return 0;
        }

        int index = 0;
        TView current = last;

        do {
            index++;
            current = current.getNext();
            if (current == view) {
                return index;
            }
        } while (current != last);

        return 0;
    }

    /**
     * Returns the subview at the given 1-based {@code index} or {@code null}
     * if the index is out of range. Index {@code 1} corresponds to the first
     * subview (the one closest to the top in Z-order).
     */
    public TView at(int index) {
        if (last == null || index <= 0) {
            return null;
        }
        TView first = last.getNext();
        TView p = first;
        int currentIndex = 1;
        do {
            if (currentIndex == index) {
                return p;
            }
            p = p.getNext();
            currentIndex++;
        } while (p != first);
        return null;
    }

    /**
     * Inserts the view into the group's subview list. The new subview is placed
     * on top of all other subviews (before the first one in the list).
     *
     * <p>If the view has the OF_CENTER_X and/or OF_CENTER_Y flags set,
     * it is centered accordingly in the group. If the view has the SF_VISIBLE flag set,
     * it will be shown in the group; otherwise, it remains hidden until explicitly shown.
     * If the view has the OF_SELECTABLE flag set, it becomes the currently selected subview.</p>
     */
    public void insert(TView view) {
        logger.trace("{} TGroup@insert({})", getLogName(), view != null ? view.getLogName() : "null");

        insertBefore(view, first());
    }

    /**
     * Inserts the view given by {@code p} in front of the view given by {@code target}.
     * If {@code target} is null, the view is placed behind all other subviews in the group.
     */
    public void insertBefore(TView p, TView target) {
        logger.trace("{} TGroup@insertBefore({}, {})", getLogName(), p != null ? p.getLogName() : "null",
                target != null ? target.getLogName() : "null");

        if (p != null && p.getOwner() == null && (target == null || target.getOwner() == this)) {
            if ((p.getOptions() & Options.OF_CENTER_X) != 0) {
                p.origin.x = (size.x - p.size.x) / 2;
            }
            if ((p.getOptions() & Options.OF_CENTER_Y) != 0) {
                p.origin.y = (size.y - p.size.y) / 2;
            }
            int saveState = p.state;
            p.hide();
            insertView(p, target);
            if ((saveState & State.SF_VISIBLE) != 0) {
                p.show();
            }
            if ((state & State.SF_ACTIVE) != 0) {
                p.setState(State.SF_ACTIVE, true);
            }
        }
    }

    /**
     * Inserts the view {@code p} into the circular subview list before {@code target}.
     * If {@code target} is null, {@code p} is appended to the end of the list.
     */
    protected void insertView(TView p, TView target) {
        logger.trace("{} TGroup@insertView({}, {})", getLogName(), p, target);

        p.setOwner(this);
        if (target != null) {
            target = target.prev();
            p.next = target.next;
            target.next = p;
        } else {
            if (last == null) {
                p.next = p;
            } else {
                p.next = last.next;
                last.next = p;
            }
            last = p;
        }
    }

    /**
     * Locks the group, delaying any screen writes by subviews until the group
     * is unlocked. Lock has no effect unless the group has a cache buffer
     * (see OF_BUFFERED and TGroup.buffer).
     *
     * <p>Lock works by incrementing a lock count, which is decremented by
     * corresponding calls to {@link #unlock()}. When {@code unlock()} decrements
     * the count to zero, the entire group is written to the screen using the image
     * constructed in the cache buffer.
     *
     * <p>By sandwiching draw-intensive operations between {@code lock()} and
     * {@code unlock()}, screen flicker can be reduced or eliminated. For example,
     * methods like TDeskTop.tile() and TDeskTop.cascade() rely on this.
     *
     * <p><strong>Important:</strong> Lock and unlock calls must be balanced.
     * Otherwise, the group may remain permanently locked and not redraw properly.
     */
    public void lock() {
        logger.trace("{} TGroup@lock()", getLogName());

        if (buffer != null || lockFlag != 0) {
            lockFlag++;
        }
    }

    /**
     * Writes a pointer to {@code view} relative to this group. The pointer is
     * encoded as the 1-based index of the view within the group's subview ring
     * or {@code 0} if the view is {@code null} or not owned by this group.
     *
     * <p>This corresponds to Turbo Vision's {@code TGroup.PutSubViewPtr}.</p>
     */
    public void putSubViewPtr(TStream stream, TView view) throws IOException {
        stream.writeInt(indexOf(view));
    }

    /**
     * Redraws the group's subviews in Z-order.
     *
     * <p>TGroup.redraw differs from TGroup.draw in that redraw will never draw from
     * the cache buffer.
     */
    public void redraw() {
        logger.trace("{} TGroup@redraw()", getLogName());

        drawSubViews(first(), null);
    }

    void removeView(TView p) {
        if (p == null || last == null) {
            return;       // nothing to remove
        }

        TView current = last;
        do {
            TView candidate = current.next;     // candidate to remove
            if (candidate == p) {
                // unlink p
                current.next = p.next;

                // adjust 'last' pointer if we removed the last element
                if (last == p) {
                    last = (p.next == p) ? null : current;  // list becomes empty or shift last
                }
                break;            // removal complete
            }
            current = candidate;                 // advance around the ring
        } while (current != last);       // stop after full circle if p not found
    }

    /**
     * Sets the current view to the first visible and selectable view.
     */
    protected void resetCurrent() {
        logger.trace("{} TGroup@resetCurrent()", getLogName());

        setCurrent(firstMatch(State.SF_VISIBLE, Options.OF_SELECTABLE), SelectMode.NORMAL_SELECT);
    }

    @Override
    protected void resetCursor() {
        if (current != null) {
            current.resetCursor();
        }
    }

    /**
     * Sets or clears the SF_SELECTED state for the specified view.
     */
    private void selectView(TView v, boolean enable) {
        logger.trace("{} TGroup@selectView({}, {})", getLogName(), v != null ? v.getLogName() : "null", enable);

        if (v != null) {
            v.setState(State.SF_SELECTED, enable);
        }
    }

    /**
     * Sets or clears the SF_FOCUSED state for the specified view.
     */
    private void focusView(TView v, boolean enable) {
        logger.trace("{} TGroup@focusView({}, {})", getLogName(), v != null ? v.getLogName() : "null", enable);

        if ((this.state & State.SF_FOCUSED) != 0 && v != null) {
            v.setState(State.SF_FOCUSED, enable);
        }
    }

    public void selectNext(boolean forwards) {
        TView v = findNext(forwards);
        if (v != null) {
            v.select();
        }
    }

    /**
     * Changes the current view and updates selection and focus states.
     */
    protected void setCurrent(TView v, SelectMode mode) {
        logger.trace("{} TGroup@setCurrent({}, {})", getLogName(), v != null ? v.getLogName() : "null", mode);

        if (current != v) {
            lock();
            focusView(current, false);
            if (mode != SelectMode.ENTER_SELECT) {
                selectView(current, false);
            }
            if (mode != SelectMode.LEAVE_SELECT) {
                selectView(v, true);
            }
            focusView(v, true);
            current = v;
            unlock();
        }
    }

    @Override
    public void setData(ByteBuffer src) {
        if (last == null) return;

        TView p = last.getNext();
        do {
            int sz = p.dataSize();
            ByteBuffer slice = src.slice();
            slice.limit(sz);
            p.setData(slice);
            src.position(src.position() + sz);
            p = p.getNext();
        } while (p != last.getNext());
    }


    @Override
    public void setState(int state, boolean enable) {
        super.setState(state, enable);
        switch (state) {
            case State.SF_ACTIVE:
            case State.SF_DRAGGING:
                lock();
                forEach(p -> p.setState(state, enable));
                unlock();
                break;
            case State.SF_FOCUSED:
                if (current != null) {
                    current.setState(state, enable);
                }
                break;
            case State.SF_EXPOSED:
                forEach(p -> {
                    if ((p.state & State.SF_VISIBLE) != 0) {
                        p.setState(state, enable);
                    }
                });
                if (!enable) {
                    freeBuffer();
                }
                break;
        }
    }

    /**
     * Unlocks the group by decrementing its lock count. If the lock count
     * becomes zero, then the entire group is written to the screen using the
     * image constructed in the cache buffer.
     */
    public void unlock() {
        logger.trace("{} TGRoup@unlock()", getLogName());

        if (lockFlag != 0) {
            lockFlag--;
            if (lockFlag == 0) {
                drawView();
            }
        }
    }

    @Override
    public boolean valid(int command) {
        if (command == Command.CM_RELEASED_FOCUS) {
            if (current != null && (current.options & Options.OF_VALIDATE) != 0) {
                return current.valid(command);
            }
        } else {
            return firstThat(v -> !v.valid(command)) == null;
        }
        return true;
    }

}
