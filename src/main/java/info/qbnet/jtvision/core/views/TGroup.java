package info.qbnet.jtvision.core.views;

import info.qbnet.jtvision.core.objects.TRect;
import info.qbnet.jtvision.util.IBuffer;

import java.util.function.Predicate;

/**
 * TGroup objects and their derivatives (which we call groups for short)
 * provide the central driving power to Turbo Vision. A group is a special
 * breed of view. In addition to all the fields and methods derived from
 * TView, a group has additional fields and methods (including many
 * overrides) allowing it to control a dynamically linked list of views
 * (including other groups) as though they were a single object. We often talk
 * about the subviews of a group even when these subviews are often
 * groups in their own right.
 *
 * Although a group has a rectangular boundary from its TView ancestry, a
 * group is only visible through the displays of its subviews. A group
 * conceptually draws itself via the draw methods of its subviews. A group
 * owns its subviews, and together they must be capable of drawing (filling)
 * the group's entire rectangular bounds. During the life of an application,
 * subviews and subgroups are created, inserted into groups, and displayed
 * as a result of user activity and events generated by the application itself.
 * The subviews can just as easily be hidden, deleted from the group, or
 * disposed of by user actions (such as closing a window or quitting a dialog box).
 *
 * The three derived object types of TGroup, namely TWindow, TDeskTop, and
 * TApplication (via TProgram) illustrate the group and subgroup concept.
 * TApplication will typically own a TDeskTop object, a TStatusLine object, and
 * a TMenuView object. TDeskTop is a TGroup derivative, so it, in turn, can
 * own TWindow objects, which in turn own TFrame objects, TScrollBar
 * objects, and so on.
 *
 * TGroup objects delegate both drawing and event handling to their
 * subviews. Many of the basic TView methods are overridden in TGroup
 * in a natural way. For example, storing and loading groups on streams
 * can be achieved with single calls to TGroup.store and TGroup.load.
 *
 * TGroup objects are not usually instantiated directly; rather you would
 * instantiate one or more of TGroup's derived object types: TApplication,
 * TDeskTop, and TWindow.
 */
public class TGroup extends TView {

    /**
     * Points to the last subview in the group (the one furthest from the top in
     * Z-order). The next field of the last subview points to the first subview,
     * whose next field points to the next subview, and so on, forming a circular list.
     */
    protected TView last = null;

    /**
     * Points to the subview that is currently selected, or is null if no subview is
     * selected.
     */
    protected TView current = null;

    /**
     * Points to a buffer used to cache redraw operations, or is null if the group
     * has no cache buffer. Cache buffers are created and destroyed
     * automatically, unless the OF_BUFFERED flag is cleared in the group's Options
     * field.
     */
    protected IBuffer buffer = null;

    /**
     * Stores the clipping rectangle for the group.
     */
    protected TRect clip = new TRect(0, 0, 0, 0);

    /**
     * Used to lock view updates during complex operations.
     */
    private int lockFlag = 0;

    /**
     * Enumerates selection modes when changing the current view.
     */
    enum SelectMode {
        NORMAL_SELECT,
        ENTER_SELECT,
        LEAVE_SELECT,
    }

    /**
     * Constructs a new TGroup within the given bounds.
     * Calls TView constructor, sets OF_SELECTABLE and OF_BUFFERED in Options,
     * and sets EventMask to 0xFFFF.
     */
    public TGroup(TRect bounds) {
        super(bounds);
        getExtent(clip);

        logger.debug("{} TGroup@TGroup(bounds={})", getLogName(), bounds);
    }

    /**
     * Overrides TView.draw. If a cache buffer exists (see TGroup.buffer field),
     * then the buffer is written to the screen using TView.writeBuf.
     * Otherwise, each subview is told to draw itself using a call to TGroup.drawSubViews.
     */
    @Override
    public void draw() {
        logger.trace("{} TGroup@draw()", getLogName());

        super.draw();
        // TODO
    }

    /**
     * Draws a range of subviews starting from p up to but not including bottom.
     */
    void drawSubViews(TView p, TView bottom) {
        if (p != null) {
            while (p != bottom) {
                p.drawView();
                p = p.getNext();
            }
        }
    }

    /**
     * Returns a reference to the first subview (the one closest to the top in Z-order),
     * or null if the group has no subviews.
     */
    public TView first() {
        if (last == null)
            return null;
        else
            return last.getNext();
    }

    /**
     * Returns the first view that matches the given state and options flags.
     */
    private TView firstMatch(int state, int options) {
        return firstThat(v -> (v.getState() & state) == state && (v.getOptions() & options) == options);
    }

    /**
     * Applies a boolean predicate to each subview in Z-order until the predicate returns true.
     * The result is the subview for which the predicate returned true, or null if it returned false
     * for all subviews.
     *
     * <p>This method is typically used to implement search functions such as hit-testing.</p>
     */
    public TView firstThat(Predicate<TView> predicate) {
        if (last == null) return null;

        TView current = last.getNext();
        do {
            if (predicate.test(current)) return current;
            current = current.getNext();
        } while (current != last.getNext());

        return null;
    }

    /**
     * Inserts the view into the group's subview list. The new subview is placed
     * on top of all other subviews (before the first one in the list).
     *
     * <p>If the view has the OF_CENTER_X and/or OF_CENTER_Y flags set,
     * it is centered accordingly in the group. If the view has the SF_VISIBLE flag set,
     * it will be shown in the group; otherwise, it remains hidden until explicitly shown.
     * If the view has the OF_SELECTABLE flag set, it becomes the currently selected subview.</p>
     */
    public void insert(TView view) {
        logger.trace("{} TGroup@insert({})", getLogName(), view != null ? view.getLogName() : "null");

        insertBefore(view, first());
    }

    /**
     * Inserts the view given by {@code p} in front of the view given by {@code target}.
     * If {@code target} is null, the view is placed behind all other subviews in the group.
     */
    public void insertBefore(TView p, TView target) {
        logger.trace("{} TGroup@insertBefore({}, {})", getLogName(), p != null ? p.getLogName() : "null",
                target != null ? target.getLogName() : "null");

        if (p != null && p.getOwner() == null && (target == null || target.getOwner() == this)) {
            if ((p.getOptions() & Options.OF_CENTER_X) != 0) {
                p.origin.x = (size.x - p.size.x) / 2;
            }
            if ((p.getOptions() & Options.OF_CENTER_Y) != 0) {
                p.origin.y = (size.y - p.size.y) / 2;
            }
            int saveState = p.getState();
            p.hide();
            insertView(p, target);
            if ((saveState & State.SF_VISIBLE) != 0) {
                p.show();
            }
            if ((state & State.SF_ACTIVE) != 0) {
                p.setState(State.SF_ACTIVE, true);
            }
        }
    }

    /**
     * Inserts the view {@code p} into the circular subview list before {@code target}.
     * If {@code target} is null, {@code p} is appended to the end of the list.
     */
    private void insertView(TView p, TView target) {
        logger.trace("{} TGroup@insertView({}, {})", getLogName(), p, target);

        p.setOwner(this);
        if (target != null) {
            target = target.prev();
            p.next = target.next;
            target.next = p;
        } else {
            if (last == null) {
                p.next = p;
            } else {
                p.next = last.next;
                last.next = p;
            }
            last = p;
        }
    }

    /**
     * Locks the group, delaying any screen writes by subviews until the group
     * is unlocked. Lock has no effect unless the group has a cache buffer
     * (see OF_BUFFERED and TGroup.buffer).
     *
     * <p>Lock works by incrementing a lock count, which is decremented by
     * corresponding calls to {@link #unlock()}. When {@code unlock()} decrements
     * the count to zero, the entire group is written to the screen using the image
     * constructed in the cache buffer.
     *
     * <p>By sandwiching draw-intensive operations between {@code lock()} and
     * {@code unlock()}, screen flicker can be reduced or eliminated. For example,
     * methods like TDeskTop.tile() and TDeskTop.cascade() rely on this.
     *
     * <p><strong>Important:</strong> Lock and unlock calls must be balanced.
     * Otherwise, the group may remain permanently locked and not redraw properly.
     */
    public void lock() {
        logger.trace("{} TGroup@lock()", getLogName());

        if (buffer != null || lockFlag != 0) {
            lockFlag++;
        }
    }

    /**
     * Sets the current view to the first visible and selectable view.
     */
    protected void resetCurrent() {
        logger.trace("{} TGroup@resetCurrent()", getLogName());

        setCurrent(firstMatch(State.SF_VISIBLE, Options.OF_SELECTABLE), SelectMode.NORMAL_SELECT);
    }

    /**
     * Sets or clears the SF_SELECTED state for the specified view.
     */
    private void selectView(TView v, boolean enable) {
        logger.trace("{} TGroup@selectView({}, {})", getLogName(), v != null ? v.getLogName() : "null", enable);

        if (v != null) {
            v.setState(State.SF_SELECTED, enable);
        }
    }

    /**
     * Sets or clears the SF_FOCUSED state for the specified view.
     */
    private void focusView(TView v, boolean enable) {
        logger.trace("{} TGroup@focusView({}, {})", getLogName(), v != null ? v.getLogName() : "null", enable);

        if ((this.getState() & State.SF_FOCUSED) != 0 && v != null) {
            v.setState(State.SF_FOCUSED, enable);
        }
    }

    /**
     * Changes the current view and updates selection and focus states.
     */
    private void setCurrent(TView v, SelectMode mode) {
        logger.trace("{} TGroup@setCurrent({}, {})", getLogName(), v != null ? v.getLogName() : "null", mode);

        if (current != v) {
            lock();
            focusView(current, false);
            if (mode == SelectMode.ENTER_SELECT) {
                selectView(current, false);
            }
            if (mode == SelectMode.LEAVE_SELECT) {
                selectView(v, true);
            }
            focusView(v, true);
            current = v;
            unlock();
        }
    }

    /**
     * Unlocks the group by decrementing its lock count. If the lock count
     * becomes zero, then the entire group is written to the screen using the
     * image constructed in the cache buffer.
     */
    public void unlock() {
        logger.trace("{} TGRoup@unlock()", getLogName());

        if (lockFlag != 0) {
            lockFlag--;
            if (lockFlag == 0) {
                drawView();
            }
        }
    }

    // Getters and setters

    /**
     * Returns the current offscreen buffer used for drawing.
     */
    public IBuffer getBuffer() {
        logger.trace("{} TGroup@getBuffer()", getLogName());

        return buffer;
    }

}
