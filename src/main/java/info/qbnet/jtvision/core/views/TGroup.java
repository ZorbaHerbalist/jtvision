package info.qbnet.jtvision.core.views;

import info.qbnet.jtvision.core.constants.Command;
import info.qbnet.jtvision.core.event.TEvent;
import info.qbnet.jtvision.core.objects.TRect;
import info.qbnet.jtvision.util.Buffer;
import info.qbnet.jtvision.util.IBuffer;

import java.util.HashSet;
import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Predicate;

/**
 * TGroup objects and their derivatives (which we call groups for short)
 * provide the central driving power to Turbo Vision. A group is a special
 * breed of view. In addition to all the fields and methods derived from
 * TView, a group has additional fields and methods (including many
 * overrides) allowing it to control a dynamically linked list of views
 * (including other groups) as though they were a single object. We often talk
 * about the subviews of a group even when these subviews are often
 * groups in their own right.
 *
 * Although a group has a rectangular boundary from its TView ancestry, a
 * group is only visible through the displays of its subviews. A group
 * conceptually draws itself via the draw methods of its subviews. A group
 * owns its subviews, and together they must be capable of drawing (filling)
 * the group's entire rectangular bounds. During the life of an application,
 * subviews and subgroups are created, inserted into groups, and displayed
 * as a result of user activity and events generated by the application itself.
 * The subviews can just as easily be hidden, deleted from the group, or
 * disposed of by user actions (such as closing a window or quitting a dialog box).
 *
 * The three derived object types of TGroup, namely TWindow, TDeskTop, and
 * TApplication (via TProgram) illustrate the group and subgroup concept.
 * TApplication will typically own a TDeskTop object, a TStatusLine object, and
 * a TMenuView object. TDeskTop is a TGroup derivative, so it, in turn, can
 * own TWindow objects, which in turn own TFrame objects, TScrollBar
 * objects, and so on.
 *
 * TGroup objects delegate both drawing and event handling to their
 * subviews. Many of the basic TView methods are overridden in TGroup
 * in a natural way. For example, storing and loading groups on streams
 * can be achieved with single calls to TGroup.store and TGroup.load.
 *
 * TGroup objects are not usually instantiated directly; rather you would
 * instantiate one or more of TGroup's derived object types: TApplication,
 * TDeskTop, and TWindow.
 */
public class TGroup extends TView {

    /**
     * Points to the last subview in the group (the one furthest from the top in
     * Z-order). The next field of the last subview points to the first subview,
     * whose next field points to the next subview, and so on, forming a circular list.
     */
    protected TView last = null;

    /**
     * Points to the subview that is currently selected, or is null if no subview is
     * selected.
     */
    protected TView current = null;

    protected enum Phase { FOCUSED, PRE_PROCESS, POST_PROCESS }

    protected Phase phase = Phase.FOCUSED;

    /**
     * Points to a buffer used to cache redraw operations, or is null if the group
     * has no cache buffer. Cache buffers are created and destroyed
     * automatically, unless the OF_BUFFERED flag is cleared in the group's Options
     * field.
     */
    protected IBuffer buffer = null;

    protected int endState = 0;

    /**
     * Stores the clipping rectangle for the group.
     */
    protected TRect clip = new TRect(0, 0, 0, 0);

    /**
     * Used to lock view updates during complex operations.
     */
    private int lockFlag = 0;

    /**
     * Enumerates selection modes when changing the current view.
     */
    enum SelectMode {
        NORMAL_SELECT,
        ENTER_SELECT,
        LEAVE_SELECT,
    }

    /**
     * Constructs a new TGroup within the given bounds.
     * Calls TView constructor, sets OF_SELECTABLE and OF_BUFFERED in Options,
     * and sets EventMask to 0xFFFF.
     */
    public TGroup(TRect bounds) {
        super(bounds);
        getExtent(clip);
        eventMask = 0xFFFF;

        logger.debug("{} TGroup@TGroup(bounds={})", getLogName(), bounds);
    }

    public void delete(TView p) {
        logger.trace("{} TGroup@delete({})", getLogName(), p.getLogName());

        int saveState = p.state;
        p.hide();
        removeView(p);
        p.owner = null;
        p.next = null;
        if ((saveState & State.SF_VISIBLE) != 0) {
            p.show();
        }
    }

    /**
     * Overrides TView.draw. If a cache buffer exists (see TGroup.buffer field),
     * then the buffer is written to the screen using TView.writeBuf.
     * Otherwise, each subview is told to draw itself using a call to TGroup.drawSubViews.
     */
    @Override
    public void draw() {
        logger.trace("{} TGroup@draw()", getLogName());

        if (buffer == null) {
            getBuffer();
            if (buffer != null) {
                lockFlag++;
                redraw();
                lockFlag--;
            }
        }

        if (buffer != null) {
            writeBuf(0, 0, size.x, size.y, buffer.getData());
        } else {
            getClipRect(clip);
            redraw();
            getExtent(clip);
        }
    }

    /**
     * Draws a range of subviews starting from p up to but not including bottom.
     */
    void drawSubViews(TView p, TView bottom) {
        if (p != null) {
            while (p != bottom) {
                p.drawView();
                p = p.nextView();
            }
        }
    }

    @Override
    public void endModal(int command) {
        if ((state & State.SF_MODAL) != 0) {
            endState = command;
        } else {
            super.endModal(command);
        }
    }

    public void eventError(TEvent event) {
        if (owner != null) {
            owner.eventError(event);
        }
    }

    @Override
    public int execute() {
        TEvent e = new TEvent();
        do {
            endState = 0;
            do {
                getEvent(e);
                handleEvent(e);
                if (e.what != TEvent.EV_NOTHING) {
                    eventError(e);
                }
            } while (endState == 0);
        } while (!valid(endState));
        return endState;
    }

    public int execView(TView p) {
        int result = Command.CM_CANCEL;
        if (p != null) {
            int saveOptions = p.options;
            TGroup saveOwner = p.owner;
            TView saveTopView = theTopView;
            TView saveCurrent = current;
            Set<Integer> saveCommands = getCommands();
            theTopView = p;
            p.options = saveOptions & ~Options.OF_SELECTABLE;
            p.setState(State.SF_MODAL, true);
            setCurrent(p, SelectMode.ENTER_SELECT);
            if (saveOwner == null) {
                insert(p);
            }
            result = p.execute();
            if (saveOwner == null) {
                delete(p);
            }
            setCurrent(saveCurrent, SelectMode.LEAVE_SELECT);
            p.setState(State.SF_MODAL, false);
            p.options = saveOptions;
            theTopView = saveTopView;
            setCommands(saveCommands);
        }

        return result;
    }

    /**
     * Returns a reference to the first subview (the one closest to the top in Z-order),
     * or null if the group has no subviews.
     */
    public TView first() {
        if (last == null)
            return null;
        else
            return last.getNext();
    }

    /**
     * Returns the first view that matches the given state and options flags.
     */
    private TView firstMatch(int state, int options) {
        return firstThat(v -> (v.getState() & state) == state && (v.getOptions() & options) == options);
    }

    /**
     * Applies a boolean predicate to each subview in Z-order until the predicate returns true.
     * The result is the subview for which the predicate returned true, or null if it returned false
     * for all subviews.
     *
     * <p>This method is typically used to implement search functions such as hit-testing.</p>
     */
    public TView firstThat(Predicate<TView> predicate) {
        if (last == null) return null;

        TView current = last.getNext();
        do {
            if (predicate.test(current)) return current;
            current = current.getNext();
        } while (current != last.getNext());

        return null;
    }

    public void forEach(Consumer<TView> action) {
        if (last == null) return;

        TView current = last.getNext();
        do {
            action.accept(current);
            current = current.getNext();
        } while (current != last.getNext());
    }

    private void freeBuffer() {
        if ((options & Options.OF_BUFFERED) != 0 && buffer != null) {
            buffer = null;
        }
    }

    private void getBuffer() {
        if (buffer != null && ((getState() & State.SF_EXPOSED) != 0) && ((getOptions() & Options.OF_BUFFERED) != 0)) {
            buffer = new Buffer(size.x, size.y);
        }
    }

    @Override
    public int getHelpCtx() {
        int h = HelpContext.HC_NO_CONTEXT;
        if (current != null) {
            h = current.getHelpCtx();
        }
        if (h == HelpContext.HC_NO_CONTEXT) {
            h = super.getHelpCtx();
        }
        return h;
    }

    @Override
    public void handleEvent(TEvent event) {
        boolean logEvent = LOG_EVENTS && event.what != TEvent.EV_NOTHING;
        if (logEvent) {
            logger.trace("{} TGroup@handleEvent(event={})", getLogName(), event);
        }

        Consumer<TView> doHandleEvent = p -> {
            if (p == null || ((p.state & State.SF_DISABLED) != 0 && (event.what & (TEvent.POSITIONAL_EVENTS | TEvent.FOCUSED_EVENTS)) != 0)) {
                return;
            }
            switch (phase) {
                case PRE_PROCESS:
                    if ((p.options & Options.OF_PRE_PROCESS) == 0) return;
                    break;
                case POST_PROCESS:
                    if ((p.options & Options.OF_POST_PROCESS) == 0) return;
                    break;
            }
            if ((event.what & p.eventMask) != 0) {
                boolean childLog = LOG_EVENTS && event.what != TEvent.EV_NOTHING;
                if (childLog) {
                    logger.trace("{} TGroup@handleEvent -> {} event={}", getLogName(),
                            p.getLogName(), event);
                }
                int before = event.what;
                p.handleEvent(event);
                if (childLog) {
                    logger.trace("{} TGroup@handleEvent <- {} handled={} event={}", getLogName(),
                            p.getLogName(), event.what == TEvent.EV_NOTHING && before != TEvent.EV_NOTHING, event);
                }
            }
        };

        Predicate<TView> containsMouse = p ->
                ((p.state & State.SF_VISIBLE) != 0) && p.mouseInView(event.mouse.where);

        super.handleEvent(event);

        if ((event.what & TEvent.FOCUSED_EVENTS) != 0) {
            phase = Phase.PRE_PROCESS;
            forEach(doHandleEvent);
            phase = Phase.FOCUSED;
            doHandleEvent.accept(current);
            phase = Phase.POST_PROCESS;
            forEach(doHandleEvent);
        } else {
            phase = Phase.FOCUSED;
            if ((event.what & TEvent.POSITIONAL_EVENTS) != 0)
                doHandleEvent.accept(firstThat(containsMouse));
            else
                forEach(doHandleEvent);
        }

        if (logEvent) {
            logger.trace("{} TGroup@handleEvent() eventAfter={} handled={}",
                    getLogName(), event, event.what == TEvent.EV_NOTHING);
        }
    }

    /**
     * Inserts the view into the group's subview list. The new subview is placed
     * on top of all other subviews (before the first one in the list).
     *
     * <p>If the view has the OF_CENTER_X and/or OF_CENTER_Y flags set,
     * it is centered accordingly in the group. If the view has the SF_VISIBLE flag set,
     * it will be shown in the group; otherwise, it remains hidden until explicitly shown.
     * If the view has the OF_SELECTABLE flag set, it becomes the currently selected subview.</p>
     */
    public void insert(TView view) {
        logger.trace("{} TGroup@insert({})", getLogName(), view != null ? view.getLogName() : "null");

        insertBefore(view, first());
    }

    /**
     * Inserts the view given by {@code p} in front of the view given by {@code target}.
     * If {@code target} is null, the view is placed behind all other subviews in the group.
     */
    public void insertBefore(TView p, TView target) {
        logger.trace("{} TGroup@insertBefore({}, {})", getLogName(), p != null ? p.getLogName() : "null",
                target != null ? target.getLogName() : "null");

        if (p != null && p.getOwner() == null && (target == null || target.getOwner() == this)) {
            if ((p.getOptions() & Options.OF_CENTER_X) != 0) {
                p.origin.x = (size.x - p.size.x) / 2;
            }
            if ((p.getOptions() & Options.OF_CENTER_Y) != 0) {
                p.origin.y = (size.y - p.size.y) / 2;
            }
            int saveState = p.getState();
            p.hide();
            insertView(p, target);
            if ((saveState & State.SF_VISIBLE) != 0) {
                p.show();
            }
            if ((state & State.SF_ACTIVE) != 0) {
                p.setState(State.SF_ACTIVE, true);
            }
        }
    }

    /**
     * Inserts the view {@code p} into the circular subview list before {@code target}.
     * If {@code target} is null, {@code p} is appended to the end of the list.
     */
    protected void insertView(TView p, TView target) {
        logger.trace("{} TGroup@insertView({}, {})", getLogName(), p, target);

        p.setOwner(this);
        if (target != null) {
            target = target.prev();
            p.next = target.next;
            target.next = p;
        } else {
            if (last == null) {
                p.next = p;
            } else {
                p.next = last.next;
                last.next = p;
            }
            last = p;
        }
    }

    /**
     * Locks the group, delaying any screen writes by subviews until the group
     * is unlocked. Lock has no effect unless the group has a cache buffer
     * (see OF_BUFFERED and TGroup.buffer).
     *
     * <p>Lock works by incrementing a lock count, which is decremented by
     * corresponding calls to {@link #unlock()}. When {@code unlock()} decrements
     * the count to zero, the entire group is written to the screen using the image
     * constructed in the cache buffer.
     *
     * <p>By sandwiching draw-intensive operations between {@code lock()} and
     * {@code unlock()}, screen flicker can be reduced or eliminated. For example,
     * methods like TDeskTop.tile() and TDeskTop.cascade() rely on this.
     *
     * <p><strong>Important:</strong> Lock and unlock calls must be balanced.
     * Otherwise, the group may remain permanently locked and not redraw properly.
     */
    public void lock() {
        logger.trace("{} TGroup@lock()", getLogName());

        if (buffer != null || lockFlag != 0) {
            lockFlag++;
        }
    }

    /**
     * Redraws the group's subviews in Z-order.
     *
     * <p>TGroup.redraw differs from TGroup.draw in that redraw will never draw from
     * the cache buffer.
     */
    public void redraw() {
        logger.trace("{} TGroup@redraw()", getLogName());

        drawSubViews(first(), null);
    }

    void removeView(TView p) {
        if (p == null || last == null) {
            return;       // nothing to remove
        }

        TView current = last;
        do {
            TView candidate = current.next;     // candidate to remove
            if (candidate == p) {
                // unlink p
                current.next = p.next;

                // adjust 'last' pointer if we removed the last element
                if (last == p) {
                    last = (p.next == p) ? null : current;  // list becomes empty or shift last
                }
                break;            // removal complete
            }
            current = candidate;                 // advance around the ring
        } while (current != last);       // stop after full circle if p not found
    }

    /**
     * Sets the current view to the first visible and selectable view.
     */
    protected void resetCurrent() {
        logger.trace("{} TGroup@resetCurrent()", getLogName());

        setCurrent(firstMatch(State.SF_VISIBLE, Options.OF_SELECTABLE), SelectMode.NORMAL_SELECT);
    }

    /**
     * Sets or clears the SF_SELECTED state for the specified view.
     */
    private void selectView(TView v, boolean enable) {
        logger.trace("{} TGroup@selectView({}, {})", getLogName(), v != null ? v.getLogName() : "null", enable);

        if (v != null) {
            v.setState(State.SF_SELECTED, enable);
        }
    }

    /**
     * Sets or clears the SF_FOCUSED state for the specified view.
     */
    private void focusView(TView v, boolean enable) {
        logger.trace("{} TGroup@focusView({}, {})", getLogName(), v != null ? v.getLogName() : "null", enable);

        if ((this.getState() & State.SF_FOCUSED) != 0 && v != null) {
            v.setState(State.SF_FOCUSED, enable);
        }
    }

    /**
     * Changes the current view and updates selection and focus states.
     */
    protected void setCurrent(TView v, SelectMode mode) {
        logger.trace("{} TGroup@setCurrent({}, {})", getLogName(), v != null ? v.getLogName() : "null", mode);

        if (current != v) {
            lock();
            focusView(current, false);
            if (mode != SelectMode.ENTER_SELECT) {
                selectView(current, false);
            }
            if (mode != SelectMode.LEAVE_SELECT) {
                selectView(v, true);
            }
            focusView(v, true);
            current = v;
            unlock();
        }
    }

    @Override
    public void setState(int state, boolean enable) {
        super.setState(state, enable);
        switch (state) {
            case State.SF_ACTIVE:
            case State.SF_DISABLED:
                lock();
                forEach(p -> p.setState(state, enable));
                unlock();
                break;
            case State.SF_FOCUSED:
                if (current != null) {
                    current.setState(state, enable);
                }
                break;
            case State.SF_EXPOSED:
                forEach(p -> {
                    if ((p.state & State.SF_VISIBLE) != 0) {
                        p.setState(state, enable);
                    }
                });
                if (!enable) {
                    freeBuffer();
                }
                break;
        }
    }

    /**
     * Unlocks the group by decrementing its lock count. If the lock count
     * becomes zero, then the entire group is written to the screen using the
     * image constructed in the cache buffer.
     */
    public void unlock() {
        logger.trace("{} TGRoup@unlock()", getLogName());

        if (lockFlag != 0) {
            lockFlag--;
            if (lockFlag == 0) {
                drawView();
            }
        }
    }

    @Override
    public boolean valid(int command) {
        if (command == Command.CM_RELEASED_FOCUS) {
            if (current != null && (current.options & Options.OF_VALIDATE) != 0) {
                return current.valid(command);
            }
        }

        return firstThat(v -> !v.valid(command)) == null;
    }

    // Getters and setters

    /**
     * Returns the current offscreen buffer used for drawing.
     */
//    public IBuffer getBuffer() {
//        logger.trace("{} TGroup@getBuffer()", getLogName());
//
//        return buffer;
//    }

}
